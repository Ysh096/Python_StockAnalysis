# 3. Pandas를 활용한 데이터 분석

복습: No
작성일시: Feb 28, 2021 5:00 PM

# 3.1 넘파이 배열

Numpy는 Numerical Python의 줄임말로, 수치 해석, 통계 작업을 구현할 때 기본이 되는 모듈이다. 넘파이의 상당 부분이 C언어와 포트란으로 작성되어 속도가 파이썬 기본 자료 구조 사용시보다 빠르며, 다차원 배열 연산 기능은 인공지능 관련 개발에 꼭 필요한 요소이다.

### 배열 생성 및 접근

```python
import numpy as np
#배열 생성
A = np.array([[1, 2], [3, 4]])
print(A)

print(A.ndim) # 배열의 차원 반환
>>2
print(A.shape) # 튜플 형태로 반환
>>(2, 2)
print(A.dtype) # 원소 자료형
>>int32

# 원소별 최댓값, 최솟값, 평균값, 합계 구하기
print(A.max(), A.mean(), A.min(), A.sum())
>> 4 2.5 1 10

# 배열에 접근하는 방법(리스트와 유사하지만 다른 부분이 있음)
print(A[0][0], A[0][1]); print(A[1][0], A[1][1])
이렇게 리스트에서 접근하는 방법처럼 접근해도 되지만,
print(A[0, 0], A[0, 1]); print(A[1, 0], A[1, 1])
이렇게 실제로 우리가 생각하는 방식대로 입력해도 알아듣는다.

결과는 둘 다 아래와 같다.
1 2
3 4
```

### 배열 형태 바꾸기

```python
# 전치행렬
print(A.transpose())
이 경우 A의 전치행렬이 반환된다. 원본을 바꾸지는 않는다.

# 평탄화
print(A.flatten())
>> [1 2 3 4]
다차원 배열을 1차원 배열 형태로 바꾼다.
```

### 배열의 연산

```python
# 같은 크기의 행렬끼리는 사칙 연산이 가능!
>>>A
array[[1, 2],
		[3, 4]])
A가 위와 같을 때,
>>>A+A
array([[2, 4],
			[6, 8]])

>>>A-A
array([[0, 0],
			[0, 0]])

>>>A*A
array([[1, 4],
			[9, 16]])

>>>A/A
array([[1., 1.],
			[1., 1.]])
```

### 브로드캐스팅(크기가 다른 행렬끼리의 연산)

```python
A = [[1, 2], [3, 4]]
B = [10, 100]

A * B = [[10, 200], [30, 400]]
이와 같이 계산되는 것을 말한다.
B의 경우 자동으로 2*2배열이 되어 부족한 부분을 채우게 되는 것!

-->B = [[10, 100], [10, 100]]
```

### 내적 구하기

```python
m x k 행렬과 k x n 행렬을 내적하면 m x n 행렬이 된다.
넘파이에서 기본적으로 행렬간 곱셈을 하면 각 원소끼리 곱셈이 되므로, 
내적을 구하기 위해서는 dot() 함수를 사용해야 한다.

np.dot(A, B) # 앞이 행, 뒤가 열
A.dot(B) #마찬가지로 앞이 행, 뒤가 열
```

# 3.2 pandas

판다스는 금융 데이터 분석이 목적!

panel data + python data analysis → pandas

panel data: 동일한 조사 대상으로부터 여러 시점에 걸쳐 반복적으로 수집한 데이터

넘파이를 기반으로 구현하여 대부분 함수가 넘파이와 유사하며, 파이플롯과 호환이 쉬워 데이터 과학용 기본 라이브러리로 활용된다.

### 시리즈 생성

시리즈는 시간의 흐름에 따라 기록한 데이터인 시계열 데이터를 다루는 데 적합한 자료 형태이다.

리스트나 튜플 등의 시퀀스를 인수로 받아 시리즈를 생성할 수 있다.

```python
import pandas as pd
s = pd.Series([0.0, 3.6, 2.0, 5.8, 4.2, 8.0])
>>>s
0    0.0
1    3.6
2    2.0
3    5.8
4    4.2
5    8.0
dtype: float64
```

### 시리즈의 인덱스 변경

```python
>>>s.index = pd.index([0.0, 1.2, 1.8, 3.0, 3.6, 4.8])
>>>s.index.name = 'MY_IDX'
>>>s
MY_IDX
0.0    0.0
1.2    3.6
1.8    2.0
3.0    5.8
3.6    4.2
4.8    8.0
dtype: float64
```

인덱스를 별도로 지정하지 않으면 0부터 시작하는 정수형 인덱스가 자동 생성되고, 사용자가 임의로 이를 지정해 줄 수 있음! 인덱스 이름을 지정해주면 인덱스 열 위에 인덱스명이 표시된다.

시리즈명을 지정해 어떤 데이터인지 예상할 수 있도록 만들 수 있다.

```python
>>>s.name = 'MY_SERIES'
>>>s
MY_IDX
0.0    0.0
1.2    3.6
1.8    2.0
3.0    5.8
3.6    4.2
4.8    8.0
Name: MY_SERIES, dtype: float64
```

### 데이터 추가

```python
>>>s[5.9] = 5.5
>>>s
MY_IDX
0.0    0.0
1.2    3.6
1.8    2.0
3.0    5.8
3.6    4.2
4.8    8.0
5.9    5.5
Name: MY_SERIES, dtype: float64

또는 새로운 시리즈를 생성한 후 append()로 추가할 수도 있다.
이럴 경우 기존의 시리즈명과 인덱스명은 사라지므로, 필요하다면 다시 설정해야 함!
ser = pd.Series([6.7, 4.2], index=[6.8, 8.0])
s = s.append(ser)
s
0.0    0.0
1.2    3.6
1.8    2.0
3.0    5.8
3.6    4.2
4.8    8.0
5.9    5.5
6.8    6.7
8.0    4.2
```

### 데이터 인덱싱

```python
원하는 순서의 인덱스 값 구하기!
>>>s.index[-1]
8.0

원하는 순서의 밸류 값 구하기!
>>>s.values[-1]
4.2

(딕셔너리처럼) 인덱스를 이용해서 실제로 가리키는 작업을 수행할 수 있다.
>>>s.loc[8.0]
4.2

원하는 순서의 데이터 값 가져오기
>>>s.iloc[-1]
4.2

iloc와 values가 같은 역할을 하는 것 같아서 의아했는데, 
values는 결과값이 복수 개일 때 배열로 반환하고,
iloc는 결과값이 복수 개일 때 시리즈로 반환하는 차이점이 있다고 한다.
```

### 데이터 삭제

삭제하고자 하는 원소의 인덱스값을 넘겨준다.

```python
>>>s.drop(8.0)
s
0.0    0.0
1.2    3.6
1.8    2.0
3.0    5.8
3.6    4.2
4.8    8.0
5.9    5.5
6.8    6.7
dtype: float64
```

### 시리즈 정보 보기

편차, 최솟값, 사분위수, 최댓값을 확인할 수 있음.

```python
>>>s.describe()
count    9.000000
mean     4.444444
std      2.430078
min      0.000000
25%      3.600000
50%      4.200000
75%      5.800000
max      8.000000
dtype: float64
```

### 시리즈 출력하기

```python
import pandas as pd
s = pd.Series([0.0, 3.6, 2.0, 5.8, 4.2, 8.0, 5.5, 6.7, 4.2])
s.index = pd.Index([0.0, 1.2, 1.8, 3.0, 3.6, 4.8, 5.9, 6.8, 8.0])

s.index.name = 'MY_DIX'
s.name = 'MY_SERIES'

import matplotlib.pyplot as plt
plt.title("ELLIOTT_WAVE")
plt.plot(s, 'bs--')
plt.show() #파이참에서는 이게 있어야 Figure 팝업이 띄워짐
plt.xticks(s.index)
plt.yticks(s.values)
```

# 3.3 판다스 데이터프레임

시리즈는 단일 변수 관측값(삼성전자의 일별 주식 가격 등)을 기록하기에 적합하다. 하지만 여러 데이터를 한번에 기록하려면 데이터프레임을 사용하는 것이 효율적이다.

데이터프레임 = 인덱스 하나 + 여러 시리즈를 합친 자료형

엑셀 파일, HTML파일, 데이터베이스로부터 데이터를 읽어와 데이터프레임 형태로 가공할 수 있음. 그 반대도 가능!

### 딕셔너리를 이용한 데이터프레임 생성

2014년부터 2018년까지의 코스피 지수와 코스닥 지수를 이용하여 데이터프레임을 만들어보자.

```python
# 딕셔너리로 데이터프레임 생성
import pandas as pd
df = pd.DataFrame({'KOSPI': [1915, 1961, 2026, 2467, 2041],
                   'KOSDAQ': [542, 682, 631, 798, 675]})
print(df)

			KOSDAQ  KOSPI
0     542   1915
1     682   1961
2     631   2026
3     798   2467
4     675   2041

# 인덱스 추가
import pandas as pd
df = pd.DataFrame({'KOSPI': [1915, 1961, 2026, 2467, 2041],
                   'KOSDAQ': [542, 682, 631, 798, 675]},
                  index = [2014, 2015, 2016, 2017, 2018])
print(df)

				KOSDAQ  KOSPI
2014     542   1915
2015     682   1961
2016     631   2026
2017     798   2467
2018     675   2041

# 시리즈와 마찬가지로, describe() 를 사용할 수 있음.
print(df.describe())

			 KOSDAQ        KOSPI
count    5.000000     5.000000
mean   665.600000  2082.000000
std     92.683871   221.117616
min    542.000000  1915.000000
25%    631.000000  1961.000000
50%    675.000000  2026.000000
75%    682.000000  2041.000000
max    798.000000  2467.000000

# 인덱스 정보, 칼럼 정보, 메모리 사용량 등을 확인하는 데 info() 메서드 사용 가능.
print(df.info())
<class 'pandas.core.frame.DataFrame'>
Int64Index: 5 entries, 2014 to 2018
Data columns (total 2 columns):
KOSDAQ    5 non-null int64 # 첫 번째 칼럼 정보
KOSPI     5 non-null int64 # 두 번째 칼럼 정보
dtypes: int64(2)
memory usage: 120.0 bytes
```

### 시리즈를 이용한 데이터프레임 생성

```python

kospi = pd.Series([1915, 1961, 2026, 2467, 2041],
                  index = [2014, 2015, 2016, 2017, 2018], name='KOSPI')

kosdaq = pd.Series([542, 682, 631, 798, 675],
                   index=[2014, 2015, 2016, 2017, 2018], name='KOSDAQ')

df = pd.DataFrame({kospi.name: kospi, kosdaq.name: kosdaq})
print(df)

			KOSDAQ  KOSPI
2014     542   1915
2015     682   1961
2016     631   2026
2017     798   2467
2018     675   2041
```

시리즈를 하나하나 만들고 딕셔너리 형태로 입력시켜주기..

### 리스트를 이용한 데이터프레임 생성

```python
columns = ['KOSPI', 'KOSDAQ']
index = [2014, 2015, 2016, 2017, 2018]
rows = []
rows.append([1915, 542])
rows.append([1961, 682])
rows.append([2026, 631])
rows.append([2467, 798])
rows.append([2041, 675])
df = pd.DataFrame(rows, columns=columns, index=index)
print(rows)
print(df)

[[1915, 542], [1961, 682], [2026, 631], [2467, 798], [2041, 675]]

      KOSPI  KOSDAQ
2014   1915     542
2015   1961     682
2016   2026     631
2017   2467     798
2018   2041     675
```

### 데이터프레임 순회 처리(데이터프레임 읽는 방법)

```python
for i in df.index:
    print(i, df['KOSPI'][i], df['KOSDAQ'][i])

#행->열 순서가 아니라 데이터 이름->행 번호 순서로 읽어올 수가 있는듯..

# itertuples는 데이터프레임의 각 행을 이름있는 튜플 형태로 반환한다!
for row in df.itertuples(name='KRX'): #KRX라는 이름의 튜플로 반환
    print(row)
KRX(Index=2014, KOSPI=1915, KOSDAQ=542)
KRX(Index=2015, KOSPI=1961, KOSDAQ=682)
KRX(Index=2016, KOSPI=2026, KOSDAQ=631)
KRX(Index=2017, KOSPI=2467, KOSDAQ=798)
KRX(Index=2018, KOSPI=2041, KOSDAQ=675)

for row in df.itertuples(name='KRX'): #KRX라는 이름의 튜플로 반환
    print(row[0], row[1], row[2])
# 일반적으로 이렇게 사용한다고 함. 이렇게 하면 그 값만 보여줌
2014 1915 542
2015 1961 682
2016 2026 631
2017 2467 798
2018 2041 675

# iterrows() 를 사용하면 각 행을 인덱스와 시리즈로 반환한다. 사용법은 itertuples와 비슷하다.

for idx, row in df.iterrows():
    print(idx, row[0], row[1])
2014 1915 542
2015 1961 682
2016 2026 631
2017 2467 798
2018 2041 675
```

# 3.4 주식 비교하기